/*
 Navicat MySQL Data Transfer

 Source Server         : MySQL
 Source Server Type    : MySQL
 Source Server Version : 80025
 Source Host           : localhost:3306
 Source Schema         : blog

 Target Server Type    : MySQL
 Target Server Version : 80025
 File Encoding         : 65001

 Date: 01/06/2022 16:13:59
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for article
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article`  (
  `article_id` int UNSIGNED NOT NULL AUTO_INCREMENT,
  `id` int UNSIGNED NOT NULL,
  `first_title` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `second_title` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `tag` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `time` bigint NOT NULL,
  `content` longtext CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  PRIMARY KEY (`article_id`) USING BTREE,
  INDEX `user_id`(`id`) USING BTREE,
  CONSTRAINT `user_id` FOREIGN KEY (`id`) REFERENCES `user` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE = InnoDB AUTO_INCREMENT = 75 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of article
-- ----------------------------
INSERT INTO `article` VALUES (58, 1, '学习总结', 'Web学习', 'Java', 1638625459199, '## 现阶段总结\n\n**主要内容：** 看尚硅谷学习JavaWeb\n\n\n*知识点：*\n- HTML、CSS\n- JS、jQuery\n- XML、Tomcat\n- Servlet程序、JSP、EL表达式、JSTL标签库\n- Cookie\n\n写文件访问路径时有点问题；视频中的书城项目看需要用到数据库连接池等知识，就没有看项目了，学完JavaWeb去学JDBC；跳过了书城项目学后面发现有些知识是项目里面讲的，还是老老实实回头看书城项目，接下来把Cookie学完。');
INSERT INTO `article` VALUES (59, 2, '二叉树', '树', 'C', 1638625740862, '##二叉树的性质\n\n1.二叉树的子树有**左右之分**，其次序不能颠倒。\n\n2.二叉树的第i层上最多有**2^(i-1)**个结点。\n\n3.深度为k的二叉树最多有**2^k-1**个结点。\n\n4.设二叉树的总结点数为N，终端（度为0）结点数为N0,度为1的结点数为N1，度为2的结点数为N2，分支总数为B，则有以下关系式：\nN=N0+N1+N2=B+1;\n\n因为除了根节点以外，其余结点都有分支进入，则有：\nB=N1+2*N2;\nN=N1+2*N2+1;\n\n结合上面式子可得：**N0=N2+1**，即终端结点数等于度为2的结点数加1；\n\n**完全二叉树**：深度为k的、有n个结点的二叉树，每一个结点都与深度为k的满二叉树中编号从1到n的结点一一对应。（也就是说若除去层次最大的那一层该树就相当于一棵满二叉树；层次最大的一层结点从左到右依次存在）\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2021032813024410.png)\n**完全二叉树性质：**\n\n1.具有n个结点的完全二叉树深度为|log2n|+1;\n\n2.一个总结点为n的完全二叉树，按层次从1到n进行编号，对于任一编号为i的结点：\n\n（1）若i=1,则该结点是二叉树的根；\n（2）若i>1,则该结点的双亲编号为i/2；\n（3）若2*i>n，则结点i无左孩子，否则其左孩子结点编号为2*i;\n（4）若2*i+1>n,则结点i无右孩子，否则其右孩子结点编号为2*i+1;\n\n\n## 二叉树的建立与遍历\n\n二叉树的存储可用顺序存储结构或链式存储结构，但是顺序存储结构仅适用于完全二叉树，对于空结点来讲会浪费许多内存空间，所以一般使用链式存储结构。\n\n*最初建树时使用一级指针建立二叉树，怎么都运行不出来，但检查不出问题，在网上找的代码大多是利用二级指针建树，书上用的是引用类型传参而C语言不支持，问题出在传参上。*\n\n错误代码示例\n```c\nvoid CreateBITree(BiTree T)\n{\n    char ch;\n    scanf(\"%c\", &ch);\n    if (ch == \'#\')\n    {\n        T = NULL;\n    }\n    else\n    {\n        T = (BiTree)malloc(sizeof(BiTNode));\n        if (!T)\n        {\n            return;\n        }\n        else\n        {\n            T->data = ch;\n            CreateBiTree(T->L);\n            CreateBiTree(T->R);\n        }\n    }\n}\n```\n\n最终去百度得到的答案是：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210328183117230.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUyNTc1NjA0,size_16,color_FFFFFF,t_70#pic_center)\n所以一般我们利用二级指针建树，不过也可以通过返回结点指针来利用一级指针建树。\n\n**二叉树的建立**\n\n1.先序（根左右）\n\n```c\nBiTree CreatePreOrderTree() //先序建树\n{\n    BiTree T;\n    char ch;\n    scanf(\"%c\", &ch);\n    if (ch == \'#\')\n    {\n        T = NULL;\n    }\n    else\n    {\n        T = (BiTree)malloc(sizeof(BiTNode));\n        T->data = ch;\n        T->L = CreatePreOrderTree();\n        T->R = CreatePreOrderTree();\n    }\n    return T;\n}\nvoid PreOrderTraverse(BiTree T) //先序遍历\n{\n    if (T == NULL)\n    {\n        return;\n    }\n    else\n    {\n        printf(\"%c \", T->data);\n        PreOrderTraverse(T->L);\n        PreOrderTraverse(T->R);\n    }\n}\n```\n2.中序（左根右)\n\n```c\nBiTree CreateInOrderTree() //中序建树\n{\n    BiTree T;\n    char ch;\n    scanf(\"%c\", &ch);\n    if (ch == \'#\')\n    {\n        T = NULL;\n    }\n    else\n    {\n        T = (BiTree)malloc(sizeof(BiTNode));\n        T->L =  CreateInOrderTree();\n        T->data = ch;\n        T->R =  CreateInOrderTree();\n    }\n    return T;\n}\nvoid InOrderTraverse(BiTree T) //中序遍历\n{\n    if (T == NULL)\n    {\n        return;\n    }\n    else\n    {\n        InOrderTraverse(T->L);\n        printf(\"%c \", T->data);\n        InOrderTraverse(T->R);\n    }\n}\n```\n3.后序（左右根）\n```c\nBiTree CreateInOrderTree() //后序建树\n{\n    BiTree T;\n    char ch;\n    scanf(\"%c\", &ch);\n    if (ch == \'#\')\n    {\n        T = NULL;\n    }\n    else\n    {\n        T = (BiTree)malloc(sizeof(BiTNode));\n        T->L =  CreateInOrderTree();\n        T->R =  CreateInOrderTree();\n        T->data = ch;\n    }\n    return T;\n}\nvoid InOrderTraverse(BiTree T) //后序遍历\n{\n    if (T == NULL)\n    {\n        return;\n    }\n    else\n    {\n        InOrderTraverse(T->L);\n        InOrderTraverse(T->R);\n        printf(\"%c \", T->data);\n    }\n}\n```\n\n４.层次（从上至下，从左至右）\n```c\nvoid LevelOrderTraversal(struct tree *root)\n{\n    struct tree *T;\n    Push(root);\n    while (!empty())\n    {\n        T = Pop();\n        printf(\"%d \", T->data);\n        if (T->left)\n        {\n            Push(T->left);\n        }\n        if (T->right)\n        {\n            Push(T->right);\n        }\n    }\n}\n\n```\n\n层次遍历和建树也可以使用数组实现\n\n```c\ntypedef struct Tree\n{\n    long long data;\n    struct Tree *L;\n    struct Tree *R;\n} TREE, *tree;\ntree *q[1111];\nint flag = 1;\n    if (flag)\n    {\n        root = malloc(sizeof(TREE));\n        root->data = sum;\n        root->L = root->R = NULL;\n        if (root->data == 0)\n        {\n            root = NULL;\n            printf(\"0 0\\n\");\n            break;\n        }\n        q[j++] = &root->L;\n        q[j++] = &root->R;\n        flag = 0;\n    }\n    else\n    {\n        m = malloc(sizeof(TREE));\n        m->data = sum;\n        m->L = m->R = NULL;\n        if (m->data != 0)\n        {\n            q[j++] = &m->L;\n            q[j++] = &m->R;\n        }\n        else\n            m = NULL;\n        *q[i++] = m;\n    }\n\n```\n不过建树最好使用链式存储结构，减少空间的浪费。\n\n**计算树的深度**\n\n```c\nint Depth(BiTree T)\n{\n    if(T==NULL)\n    {\n        return 0;\n    }\n    else\n    {\n        int a=Depth(T->L);\n        int b=Depth(T->R);\n        return a>b?(a+1):(b+1); \n    }\n}\n```\n\n**计算结点数目**\n\n```c\nint NodeNumber(BiTree T)//计算总结点数目\n{\n    if(T==NULL)\n    {\n        return 0;\n    }\n    else\n    {\n        return NodeNumber(T->L)+NodeNumber(T->R)+1;\n    }\n}\nint LeavesNodeNumber(BiTree T)//计算叶子结点数目\n{\n    if(T==NULL)\n    {\n        return 0;\n    }\n    if(T->L==NULL&&T->R==NULL)\n    {\n        return 1;\n    }\n    else\n    {\n        return NodeNumber(T->L)+NodeNumber(T->R);\n    }\n}\n```\n');
INSERT INTO `article` VALUES (60, 3, '哈夫曼树', '树', 'C', 1638625848123, '## 哈夫曼树\n\n**哈夫曼树又称最优树，是一类带权路径长度（WPL)最短的树**，权值越大的结点离根结点越近，反之则越远。\n\n一颗含有N0个叶子结点的哈夫曼树共有2N0-1个结点*（因为哈夫曼树没有度为1的结点，即可设哈夫曼树叶子结点即度为0的结点数为N0，度为2的结点数为N2，总结点为N，则有N=2*N2+1，N=N0+N2，可得N=2N0-1）*，哈夫曼树可以存储在一个大小为2*N0的动态分配的一维数组w[]中，树的每个结点存储双亲和孩子的信息*（下标）*\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210403205843996.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUyNTc1NjA0,size_16,color_FFFFFF,t_70)\n\n\n**哈夫曼树的建立**\n\n1.初始化：动态申请2n个单元，通过循环将所有单元的双亲和孩子的下标都初始化为0，再循环输入各叶子结点的权值。\n\n2.创建树：\n选择：每次选择当前森林中选择双亲为0且权值最小的两个树根结点s1和s2。\n删除：将结点s1和s2的双亲改为非0，不再进行之后的选择。\n合并：将s1和s2的权和作为一个新结点依次存入到数组的第n+1之后的单元之中，同时记录新结点左孩子下标为s1,右孩子下标s2。\n\n\n**C语言建立哈夫曼树**\n\n```c\n#include<stdio.h>\n#include<stdlib.h>\ntypedef struct HFMTree\n{\n    int W;\n    int P,L,R;\n}*HuffmanTree,HTNode;\nHuffmanTree HT;\nint s1,s2;\nvoid Select(int n)\n{\n    int min;\n    for(int i=1;i<=n;i++)\n    {\n        if(!HT[i].P)\n        {\n            min=i;\n            break;\n        }\n    }\n    for(int i=1;i<=n;i++)\n    {\n        if(!HT[i].P)\n        {\n            if(HT[i].W<HT[min].W)\n            {\n                min=i;\n            }\n        }\n    }\n    s1=min;\n    for(int i=1;i<=n;i++)\n    {\n        if(!HT[i].P&&i!=s1)\n        {\n            min=i;\n            break;\n        }\n    }\n    for(int i=1;i<=n;i++)\n    {\n        if(!HT[i].P&&i!=s1)\n        {\n            if(HT[i].W<HT[min].W)\n            {\n                min=i;\n            }\n        }\n    }\n    s2=min;\n}\nvoid CreateHuffmanTree(int *w,int n)\n{\n    int m;\n    m=2*n-1;\n    HT=malloc((m+1)*sizeof(HTNode));\n    for(int i=1;i<=n;i++)\n    {\n        HT[i].W=w[i];\n        HT[i].P=HT[i].L=HT[i].R=0;\n    }\n    for(int i=n+1;i<=m;i++)\n    {\n        HT[i].W=HT[i].P=HT[i].L=HT[i].R=0;\n    }\n    printf(\"The HuffmanTree is:\\n\");\n    for(int i=n+1;i<=m;i++)\n    {\n        Select(i-1);\n        HT[s1].P=i;\n        HT[s2].P=i;\n        HT[i].L=s1;\n        HT[i].R=s2;\n        HT[i].W=HT[s1].W+HT[s2].W;\n        printf(\"%d(%d,%d)\\n\",HT[i].W,HT[s1].W,HT[s2].W);\n    }\n    return ;\n}\nint main()\n{\n    int *w,n;\n    printf(\"Please input the number of the node:\");\n    scanf(\"%d\",&n);\n    w=malloc((n+1)*sizeof(int));\n    for(int i=1;i<=n;i++)\n    {\n        printf(\"Please input the value of the node:\");\n        scanf(\"%d\",&w[i]);\n    }\n    CreateHuffmanTree(w,n);\n    return 0;\n}\n```\n\n\n**哈夫曼编码**\n\n**性质1：**哈夫曼编码是前缀编码，任一编码都不会与其他编码的部分前缀完全重叠，不会产生二义性。\n\n**性质2：**哈夫曼编码以数据出现的次数为权值来构建哈夫曼树，使得数据长度最短。\n\n*利用哈夫曼树来对数据进行二进制编码的压缩，对于一个具有n个叶子的结点，左分支赋为0，右分支赋为1，每个叶子的路径分支构成一个二进制串即二进制编码，使得平均二进制编码长度最短达到压缩目的。*\n\n');
INSERT INTO `article` VALUES (61, 4, '图的存储', '图', 'C', 1638625911110, '**一.邻接矩阵**\n\n对具有N个结点的图构造一个N*N的矩阵，矩阵数组的下标存储结点和相应顶点的位置，数组的值即为每两个邻接顶点的边的权值。\n邻接矩阵可以表示有向或无向图，当两个顶点不邻接相通时我们可以将数组权值赋为0或**0x3f3f3f3f**(趋近无穷大值又不会溢出)。\n\n```c\n//邻接矩阵\ntypedef struct\n{\n    char vexs[MAXSIZE];\n    int arcs[MAXSIZE][MAXSIZE];\n    int vexnum,arcnum;\n}AMGraph;\n```\n\n缺点：不便于增加和删除顶点，不便于统计边的数目，时间复杂度高，空间复杂度高，对于稀疏图而言十分浪费空间。\n\n**时间复杂度：O（n^2)\n   空间复杂度：O（n^2)**\n\n**二.邻接表**\n\n邻接表：每个顶点建立一个链表，对无向图来说用于存放该顶点邻接的顶点，对有向图来说便是存放该顶点通向的邻接顶点。\n\n```c\n//邻接表\ntypedef struct ArcNode\n{\n    int adj;\n    struct ArcNode*next;\n}ArcNode;\ntypedef struct VNode\n{\n    int data;\n    ArcNode *First;\n}VNode,AdjList[MAXSIZE];\ntypedef struct\n{\n    AdjList ver;\n    int vexnum,arcnum;\n}ALGraph;\n\n```\n\n逆邻接表：每个顶点建立一个链表，存放通向该顶点的邻接顶点。\n\n\n**十字链表**：可以看作正邻接表和逆邻接表的结合，每个顶点和其结点度多设置一个指针域来存放入度。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210403203143470.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUyNTc1NjA0,size_16,color_FFFFFF,t_70)\n\n```c\n//十字链表\ntypedef struct ArcBox\n{\n    int head,tail;\n    struct ArcBox *h,*t;\n}ArcBox;\ntypedef struct VexNode\n{\n    int data;\n    ArcBox *firstin,*firstout;\n}VexNode;\ntypedef struct\n{\n    VexNode XList[MAXSIZE];\n    int vexnum,arcnum;\n}OlGragh;\n```\n\n十字链表、邻接表和逆邻接表，顶点n，边e：\n**时间复杂度：O（n+e）\n   空间复杂度：O（n+e）**\n\n**三.邻接多重表**\n\n邻接多重表是**无向图**的另一种链式存储结构，类似于十字链表；虽然邻接表是无向图的一种有效的存储结构，但当对已被搜索的边做记号或删除一条边时需要找到一条边的两个顶点，所以在对无向表进行一类操作时更适合采用邻接多重链表。\n![](https://img-blog.csdnimg.cn/20210403203005462.png)\n\n```c\n//邻接多重表\ntypedef enum{unvisited,visited} VisitIf;\ntypedef struct EBox\n{\n    VisitIf mark;\n    int ivex,jvex;\n    struct EBox *iLink,*jLink;\n}EBox;\ntypedef struct VexBox\n{\n    int data;\n    EBox *Firstedge;\n}VexBox;\ntypedef struct\n{\n    VexBox AList[MAXSIZE];\n    int vexnum,edgenum;\n}AMLGraph;\n```\n\n**图的存储应根据实际需要选择最合适的存储结构。**');
INSERT INTO `article` VALUES (62, 2, '最短路径', '图的最短路径', 'C', 1638628324595, '*一、源点到其余顶点的最短路径\n二、每一对顶点之间的最短路径*\n\n## 一、迪杰斯特拉算法(Dijkstra)\n\n*Dijkstra：解决单源最短路径，按路径长度递增的次序产生最短路径的算法。*主要找出当前源点到其他顶点最短的一条路径，再利用此路径更新源点至各顶点的最小路径，循环往复直至源点到各顶点均为最短路径。\n\n定义邻接矩阵及辅助数组\n\n```c\n#include<stdbool.h>\n#define MAXSIZE 100\n#define INF 0x3f3f3f3f\n//邻接矩阵\ntypedef struct\n{\n    char vexs[MAXSIZE];\n    int arcs[MAXSIZE][MAXSIZE];\n    int vexnum,arcnum;\n}AMGraph;\nbool S[MAXSIZE];//是否确定最短路径长度\nint D[MAXSIZE];//记录当前最短路径长度\nint P[MAXSIZE];//终点直接前驱顶点序号\n```\n\n**Dijkstra算法**\n\n```c\nvoid Dijkstra(AMGraph G,int v)\n{\n    int n=G.vexnum,i,j,l,min;\n    for(i=0;i<n;i++)\n    {\n        S[i]=false;\n        D[i]=G.arcs[v][i];\n        if(D[i]<INF)\n        {\n            P[i]=v;\n        }\n        else\n        {\n            P[i]=-1;\n        }\n    }\n    S[v]=true;\n    D[v]=0;\n    for(i=0;i<n;i++)\n    {\n        min=INF;\n        for(j=0;j<n;j++)\n        {\n            if(D[j]<min&&!S[j])\n            {\n                l=j;\n                min=D[j];\n            }\n        }\n        S[l]=true;\n        for(j=0;j<n;j++)\n        {\n            if((D[l]+G.arcs[l][j])<D[j]&&!S[j])\n            {\n                D[j]=D[l]+G.arcs[l][j];\n                P[j]=l;\n            }\n        }\n    }\n    return ;\n}\n```\n**时间复杂度：O(n^2)**\n\n\n## 二、弗洛伊德算法（Floyd）\n\n*Floyd：解决多源最短路径，形式上比Dijkstra更容易理解，因此更适合解多源最短路径。*　依次利用各个顶点进行中转来不断各个更新各个顶点之间最小路径，直至各个顶点之间均为最短路径即可。\n\n定义邻接矩阵及辅助数组\n\n```c\n#include<stdbool.h>\n#define MAXSIZE 100\n#define INF 0x3f3f3f3f\n//邻接矩阵\ntypedef struct\n{\n    char vexs[MAXSIZE];\n    int arcs[MAXSIZE][MAXSIZE];\n    int vexnum,arcnum;\n}AMGraph;\nint P[MAXSIZE][MAXSIZE];//最短路径上顶点的前一顶点的序号\nint D[MAXSIZE][MAXSIZE];//记录顶点之间的最短路径长度\n```\n**Floyd算法**\n\n```c\nvoid Floyd(AMGraph G)\n{\n    for(int i=0;i<G.vexnum;i++)\n    {\n        for(int j=0;j<G.vexnum;j++)\n        {\n            D[i][j]=G.arcs[i][j];\n            if(D[i][j]<INF&&i!=j)\n            {\n                P[i][j]=i;\n            }\n            else\n            {\n                P[i][j]=-1;\n            }\n        }\n    }\n    for(int k=0;k<G.vexnum;k++)\n    {\n        for(int i=0;i<G.vexnum;i++)\n        {\n            for(int j=0;j<G.vexnum;j++)\n            {\n                if(D[i][k]+D[k][j]<D[i][j])\n                {\n                    D[i][j]=D[i][k]+D[k][j];\n                    P[i][j]=P[k][j];\n                }\n            }\n        }\n    }\n    return ;\n}\n\n```\n**时间复杂度：O(n^3)**\n\n## 三、贝尔曼福特算法（Bellman-Ford)\n\n*Bellman-Ford:解决负权单源最短路径，其本质是动态规划思想。*主要是对图进行最多V-1次松弛操作，得到源点到各点所有可能的最短路径，遍历都结束后，若再进行一次遍历，还能得到s到某些节点更短的路径的话，则说明存在负环路，所以还能够用来检测负环。BellmanFord支持解决负权路，没有负权也可以用，不过效率比Dijkstra低很多，所以更适合解决负权问题。\n\n定义邻接矩阵及辅助数组\n\n```c\n#include<stdbool.h>\n#define MAXSIZE 100\n#define INF 0x3f3f3f3f\n//邻接矩阵\ntypedef struct\n{\n    char vexs[MAXSIZE];\n    int arcs[MAXSIZE][MAXSIZE];\n    int vexnum,arcnum;\n}AMGraph;\nint D[MAXSIZE];//记录当前最短路径长度\nint P[MAXSIZE];//终点直接前驱顶点序号\n```\n**Bellman-Ford算法**\n\n```c\nvoid BellmanFord(AMGraph G,int v)\n{\n    int n=G.vexnum;\n    for(int i=0;i<n;i++)\n    {\n        D[i]=G.arcs[v][i];\n        if(D[i]<INF)\n        {\n            P[i]=v;\n        }\n        else\n        {\n            P[i]=-1;\n        }\n    }\n    D[v]=0;\n    for(int i=2;i<G.vexnum-1;i++)\n    {\n        for(int j=0;j<G.vexnum;j++)\n        {\n            for(int k=0;k<G.vexnum;k++)\n            {\n                if((D[j]+G.arcs[j][k])<D[k])\n                {\n                    D[k]=D[j]+G.arcs[j][k];\n                    P[k]=j;\n                }\n            }\n        }\n    }\n    bool flag=true;\n    for(int i=0;i<G.vexnum-1;i++)\n    {\n        for(int j=0;j<G.vexnum-1;j++)\n        {\n            if(D[i]+G.arcs[i][j]<D[j])\n            {\n                flag=false;\n                break;\n            }\n        }\n    }\n    return flag;\n}\n```\n**时间复杂度：O(V*E)** **V（顶点数），E（边数）**\n\n\nDFS和BFS算法也可以求最短路径，但只能用于求无权图。\n\n## 最短路线\n\n利用最短路径的Path数组回溯出两点间最短路径的整条路线\n\n*邻接矩阵存储图：*\n\n```java\nvoid BeforePath(int a,int b)//参数a起点，参数b终点，根据最短路径终点前驱数组回溯路径上所有地点\n{\n	if (P[a][b] == -1)\n	{\n		return;\n	}\n	else if (P[a][b] == a)\n	{\n		printf(\"->\");\n		printf(\"%s\", Site[b].name);\n		return;\n	}\n	else\n	{\n		BeforePath(a, P[P[a][b]][b]);\n		printf(\"->\");\n		printf(\"%s\", Site[b].name);\n		return;\n	}\n}\n\n```\n*输出的路径未包括最初的起点，可以在函数外加上最初起点的输出*\n\n\n## 所有路径\n\n利用DFS算法，借助辅助数组（或栈）输出两点间所有路径\n\n*邻接矩阵存储图：*\n\n```java\nvoid DFS(int a, int b,int A)//参数a为起点，参数b为终点，参数A为最初的起点，深度搜索寻找两点间所有路径\n{\n	for (int i = 1; i <= L; i++)\n	{\n		if (S[a][i] < INF && V[i] == 0)\n		{\n			if (i == b)\n			{\n				int j;\n				printf(\"%s->\", Site[A].name);\n				for (j = 0; j < E; j++)\n				{\n					printf(\"%s->\", Site[T[j]].name);\n				}\n				printf(\"%s\\n\\n\",Site[b].name);\n				F++;\n			}\n			else\n			{\n				V[i] = 1;\n				T[E] = i;\n				E++;\n				DFS(i, b,A);\n				V[i] = 0;\n				E--;\n			}\n		}\n	}\n}\n\n```\n*为了让路线更完整，多设置了一个参数A即最初的起点，递归时参数A不变，从而输出完整路径*');
INSERT INTO `article` VALUES (63, 3, '有向无环图', '拓扑图', 'C', 1638628496001, '简称**DAG图**，*是用来描述一项工程或系统的进行过程的有效工具。*\n\n**AOV网**：用顶点表示活动，用弧表示活动间的优先关系的有向图称为AOV网，是**无权**有向无环图\n**AOE网**：用顶点表示事件，弧表示活动权表示活动持续的时间称为AOE网，是**带权**有向无环图\n\n\n\n\n## 拓扑排序\n拓扑排序就是将AOV网中所有顶点按流程次序排成一个线性序列，该线性序列并不唯一，其过程为：\n\n(1)在有向图中选一个无前驱的顶点且输出它\n(2)从图中删除该顶点和并清除以它为前驱的入度\n(3)重复一、二步骤，直至不存在无入度为0的顶点\n(4)若此时输出的顶点数小于有向图中的顶点数，则说明有向图中存在环，否则输出的顶点序列即为一个拓扑序列。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2021041110443579.png)\n\n\n*在实际操作中我们并不一定需要直接对图进行操作，可以借助辅助结构比如栈和队列来实现拓扑排序*\n\n**实现代码**\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#define MAXSIZE 100\n//邻接表\ntypedef struct ArcNode\n{\n    int adj;\n    struct ArcNode *next;\n} ArcNode;\ntypedef struct VNode\n{\n    char data;\n    ArcNode *First;\n} VNode, AdjList[MAXSIZE];\ntypedef struct\n{\n    AdjList ver;\n    int vexnum, arcnum;\n} ALGraph;\nALGraph G;\n//栈\ntypedef struct Stack\n{\n    int *base;\n    int *top;\n    int stacksize;\n} STACK;\nSTACK S;\n//栈的操作\nint InitStack()\n{\n    S.base = malloc(MAXSIZE * sizeof(int));\n    if (!S.base)\n    {\n        return 0;\n    }\n    else\n    {\n        S.top = S.base;\n        S.stacksize = MAXSIZE;\n        return 1;\n    }\n}\nint StackEmpty()\n{\n    return S.top == S.base;\n}\nint Push(int e)\n{\n    if (S.top - S.base == S.stacksize)\n    {\n        return 0;\n    }\n    else\n    {\n        *S.top++ = e;\n        S.stacksize--;\n        return 1;\n    }\n}\nint Pop()\n{\n    if (S.top == S.base)\n    {\n        return 0;\n    }\n    else\n    {\n        --S.top;\n        return 1;\n    }\n}\nint GetTop()\n{\n    if (S.top != S.base)\n    {\n        return *(S.top - 1);\n    }\n}\n//创建邻接表表示图\nvoid CreateGraph()\n{\n    ArcNode *p, *q;\n    int x, y;\n    printf(\"Please input the number of vexs:\");\n    scanf(\"%d\", &G.vexnum);\n    printf(\"Please input the number of arcs:\");\n    scanf(\"%d\", &G.arcnum);\n    getchar();\n    for (int i = 1; i <= G.vexnum; i++)\n    {\n        printf(\"Please input the %dth vex:\", i);\n        scanf(\"%c\", &G.ver[i].data);\n        getchar();\n    }\n    for (int i = 1; i <= G.arcnum; i++)\n    {\n        printf(\"Please input the start:\");\n        scanf(\"%d\", &x);\n        printf(\"Please input the end:\");\n        scanf(\"%d\", &y);\n        if (G.ver[x].First)\n        {\n            p = G.ver[x].First;\n            while (p->next)\n            {\n                p = p->next;\n            }\n            q = malloc(sizeof(ArcNode));\n            q->adj = y;\n            p->next = q;\n            q->next = NULL;\n        }\n        else\n        {\n            q = malloc(sizeof(ArcNode));\n            q->adj = y;\n            q->next = NULL;\n            G.ver[x].First = q;\n        }\n    }\n    return;\n}\n//拓扑排序\nbool TopoSort(int topo[])\n{\n    int In[MAXSIZE] = {0};\n    ArcNode *p;\n    for (int i = 1; i <= G.vexnum; i++)\n    {\n        p = G.ver[i].First;\n        while (p)\n        {\n            In[p->adj]++;\n            p = p->next;\n        }\n    }\n    for (int i = 1; i <= G.vexnum; i++)\n    {\n        if (!In[i])\n        {\n            Push(i);\n        }\n    }\n    int s, t=0,cnt = 0;\n    while (!StackEmpty())\n    {\n        s = GetTop();\n        topo[t++]=s;\n        Pop();\n        printf(\"%c\\n\", G.ver[s].data);\n        cnt++;\n        p = G.ver[s].First;\n        while (p)\n        {\n            In[p->adj]--;\n            if (!In[p->adj])\n            {\n                Push(p->adj);\n                p = p->next;\n            }\n            else\n            {\n                p = p->next;\n                continue;\n            }\n        }\n    }\n    if (cnt < G.vexnum)\n    {\n        return false;\n    }\n    else\n    {\n        return true;\n    }\n}\nint main()\n{\n    InitStack();\n    CreateGraph();\n    int topo[MAXSIZE];\n    if (TopoSort(topo))\n    {\n        printf(\"The graph has no circle!\\n\");\n    }\n    else\n    {\n        printf(\"The graph has circle!\\n\");\n    }\n    return 0;\n}\n```\n**时间复杂度：O(n+e)**\n\n\n\n## 关键路径\n\n一个工程在无环的情况下，网只有一个入度为0的点称为**源点**，只有一个出度为0的点称为**汇点**。\n\n\n**关键路径**就是从源点到汇点带权路径长度最长的路径，也是工程完成的最短时间，关键路径上的活动称为**关键活动**，关键活动是影响整个工程进度的关键，它们的提前或拖延将将使整个工程提前或拖延。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210411104913302.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUyNTc1NjA0,size_16,color_FFFFFF,t_70)\n\n \n 求解流程：\n (1)利用拓扑序列求出每个事件的**最早发生时间ve(i)**\n (2)按逆拓扑序列求出每个事件的**最迟发生时间vl(i)**\n (3)求出每个活动的**最早开始时间e(i)**\n (4)求出每个活动的**最晚开始时间l(i)**\n (5)找出e(i)=l(i)的活动，即为关键活动，其形成的由源点到汇点的每一条路径就是关键路径，关键路径有可能不止一条。\n \n **实现代码**\n \n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#define MAXSIZE 100\n//邻接表\ntypedef struct ArcNode\n{\n    int adj;\n    int weight;\n    struct ArcNode *next;\n} ArcNode;\ntypedef struct VNode\n{\n    char data;\n    ArcNode *First;\n} VNode, AdjList[MAXSIZE];\ntypedef struct\n{\n    AdjList ver;\n    int vexnum, arcnum;\n} ALGraph;\nALGraph G;\nint topo[MAXSIZE];\n//栈\ntypedef struct Stack\n{\n    int *base;\n    int *top;\n    int stacksize;\n} STACK;\nSTACK S;\n//栈的操作\nint InitStack()\n{\n    S.base = malloc(MAXSIZE * sizeof(int));\n    if (!S.base)\n    {\n        return 0;\n    }\n    else\n    {\n        S.top = S.base;\n        S.stacksize = MAXSIZE;\n        return 1;\n    }\n}\nint StackEmpty()\n{\n    return S.top == S.base;\n}\nint Push(int e)\n{\n    if (S.top - S.base == S.stacksize)\n    {\n        return 0;\n    }\n    else\n    {\n        *S.top++ = e;\n        S.stacksize--;\n        return 1;\n    }\n}\nint Pop()\n{\n    if (S.top == S.base)\n    {\n        return 0;\n    }\n    else\n    {\n        --S.top;\n        return 1;\n    }\n}\nint GetTop()\n{\n    if (S.top != S.base)\n    {\n        return *(S.top - 1);\n    }\n}\n//创建邻接表表示图\nvoid CreateGraph()\n{\n    ArcNode *p, *q;\n    int x, y, z;\n    printf(\"Please input the number of vexs:\");\n    scanf(\"%d\", &G.vexnum);\n    printf(\"Please input the number of arcs:\");\n    scanf(\"%d\", &G.arcnum);\n    getchar();\n    for (int i = 1; i <= G.vexnum; i++)\n    {\n        printf(\"Please input the %dth vex:\", i);\n        scanf(\"%c\", &G.ver[i].data);\n        getchar();\n    }\n    for (int i = 1; i <= G.arcnum; i++)\n    {\n        printf(\"Please input the start:\");\n        scanf(\"%d\", &x);\n        printf(\"Please input the end:\");\n        scanf(\"%d\", &y);\n        printf(\"Please input the weight:\");\n        scanf(\"%d\", &z);\n        if (G.ver[x].First)\n        {\n            p = G.ver[x].First;\n            while (p->next)\n            {\n                p = p->next;\n            }\n            q = malloc(sizeof(ArcNode));\n            q->adj = y;\n            q->weight = z;\n            p->next = q;\n            q->next = NULL;\n        }\n        else\n        {\n            q = malloc(sizeof(ArcNode));\n            q->adj = y;\n            q->weight = z;\n            q->next = NULL;\n            G.ver[x].First = q;\n        }\n    }\n    return;\n}\n//拓扑排序\nbool TopoSort()\n{\n    int In[MAXSIZE] = {0};\n    ArcNode *p;\n    for (int i = 1; i <= G.vexnum; i++)\n    {\n        p = G.ver[i].First;\n        while (p)\n        {\n            In[p->adj]++;\n            p = p->next;\n        }\n    }\n    for (int i = 1; i <= G.vexnum; i++)\n    {\n        if (!In[i])\n        {\n            Push(i);\n        }\n    }\n    int s, t = 1, cnt = 0;\n    printf(\"The topo sort is:\\n\");\n    while (!StackEmpty())\n    {\n        s = GetTop();\n        topo[t++] = s;\n        Pop();\n        printf(\"%c\\n\", G.ver[s].data);\n        cnt++;\n        p = G.ver[s].First;\n        while (p)\n        {\n            In[p->adj]--;\n            if (!In[p->adj])\n            {\n                Push(p->adj);\n                p = p->next;\n            }\n            else\n            {\n                p = p->next;\n                continue;\n            }\n        }\n    }\n    if (cnt < G.vexnum)\n    {\n        return false;\n    }\n    else\n    {\n        return true;\n    }\n}\n//关键路径\nvoid CriticalPath()\n{\n    ArcNode *p;\n    TopoSort();\n    int ve[MAXSIZE], vl[MAXSIZE], e, j, l, k;\n    for (int i = 1; i <= G.vexnum; i++)\n    {\n        ve[i] = 0;\n    }\n    for (int i = 1; i <= G.vexnum; i++)\n    {\n        k = topo[i];\n        p = G.ver[k].First;\n        while (p)\n        {\n            j = p->adj;\n            if (ve[j] < ve[k] + p->weight)\n            {\n                ve[j] = ve[k] + p->weight;\n            }\n            p = p->next;\n        }\n    }\n    for (int i = 1; i <= G.vexnum; i++)\n    {\n        vl[i] = ve[G.vexnum];\n    }\n    for (int i = G.vexnum; i >= 1; i--)\n    {\n        k = topo[i];\n        p = G.ver[k].First;\n        while (p)\n        {\n            j = p->adj;\n            if (vl[k] > vl[j] - p->weight)\n            {\n                vl[k] = vl[j] - p->weight;\n            }\n            p = p->next;\n        }\n    }\n    printf(\"The CriticalPath is:\\n\");\n    for (int i = 1; i <= G.vexnum; i++)\n    {\n        p = G.ver[i].First;\n        while (p)\n        {\n            j = p->adj;\n            e = ve[i];\n            l = vl[j] - p->weight;\n            if (e == l)\n            {\n                printf(\"%c->%c\\n\", G.ver[i].data, G.ver[j].data);\n            }\n            p = p->next;\n        }\n    }\n    return;\n}\nint main()\n{\n    InitStack();\n    CreateGraph();\n    CriticalPath();\n    return 0;\n}\n\n```\n\n**时间复杂度：O(n+e)**\n\n\n*实践证明，用AOE网对于估算工程完成的时间是十分有用的。我们再实施工程时对关键路径上的关键活动要十分关注，因为关键路径决定了工期的长短，与此同时，我们还可以对非关键路径上的活动进行合理安排。若网中有多条关键路径，那么单一提高一条关键路径上的是速度还不能导致整个工期缩短，必须同时提高所有关键路径上的活动速度才能达到期望值。*');
INSERT INTO `article` VALUES (64, 4, '线性表查找', '线性表', 'C', 1638628665210, '## 一、顺序查找\n\n直接遍历线性表或设置**监视哨**进行顺序查找。\n\n```c\nint Search(int a[],int key,int length)\n{\n    int i;\n    a[0]=key;//监视哨\n    for(i=length;a[i]!=key;i--);\n    return i;\n}\n```\n**时间复杂度：O(n)**\n\n设置监视哨，免去查找过程中每一步都要检测表是否查找完毕，虽然时间复杂度与直接遍历一样均为O(n)，然而实践证明，当length>=1000时，这个改进能使顺序表进行一次查找所需的平均时间几乎减少一半。\n\n\n## 二、折半查找\n\n又称**二分法**，效率较高，但要求线性表必须采用顺序存储结构且有序排列,而且不适用于数据元素经常变动的线性表。\n\n```c\n//二分非递归算法\nint Search1(int a[], int key, int length)\n{\n    int L = 0, R = length - 1, mid;\n    while (L <= R)\n    {\n        mid = (L + R) / 2;\n        if (a[mid] == key)\n        {\n            return mid;\n        }\n        else if (key < a[mid])\n        {\n            R = mid - 1;\n        }\n        else\n        {\n            L = mid + 1;\n        }\n    }\n    return 0;\n}\n```\n\n```c\n//二分递归算法\nint Search2(int a[], int key, int L, int R)\n{\n    int mid;\n    if (L > R)\n    {\n        return 0;\n    }\n    mid = (L + R) / 2;\n    if (a[mid] == key)\n    {\n        return mid;\n    }\n    else if (key < a[mid])\n    {\n        return Search2(a, key, L, mid - 1);\n    }\n    else\n    {\n        return Search2(a, key, mid + 1, R);\n    }\n}\n```\n**时间复杂度：O(log2n)**\n\n\n## 三、分块查找\n\n又称**索引顺序查找**，效率介于分块查找和折半查找之间，尚需额外建立一个**索引表**（空间换时间)，*块间有序，块内无序*。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210411153713257.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUyNTc1NjA0,size_16,color_FFFFFF,t_70)\n\n1.建立索引表，索引表按照各个块中关键字大小排序，记录各个块的起始位置。\n2.确定待查值在哪一块（折半查找或顺序查找）。\n3.在确定的块中查找待查找值（顺序查找）。\n\n*优点：不要求线性表有序，也不需要对线性表进行全部遍历*');
INSERT INTO `article` VALUES (65, 2, '树表查找', '二叉树', 'C', 1638628750297, '## 二叉排序树\n\n*又称* **二叉查找树**、**二叉搜索树**，*是一种对排序和查找都很有效的特殊二叉树。*\n\n**性质**\n\n(1)其左右子树也分别为二叉排序树\n(2)中序遍历其可得到一个递增的有序序列\n(3)左子树所有结点均小于根结点，右子树所有结点均大于根结点\n\n**二叉排序树的存储**\n```c\n//二叉排序树的存储\ntypedef struct\n{\n    int key;\n    //还可设置其他数据项\n}KeyType;\ntypedef struct BSTNode\n{\n    KeyType data;\n    struct BSTNode *L,*R; \n}BSTNode,*BSTree;\n```\n\n**二叉排序树的查找：时间复杂度O(log2n)**\n```c\n//二叉排序树的查找\nBSTree SearchBST(BSTree T,int key)\n{\n    if((!T)||key==T->data.key)\n    {\n        return T;\n    }\n    else if(key<T->data.key)\n    {\n        return SearchBST(T->L,key);\n    }\n    else\n    {\n        return SearchBST(T->R,key);\n    }\n}\n```\n\n*结点的值相同但创建树的序列不同，树的形态也会不同，但中序遍历这两棵树的序列相同，因此平均查找长度(ASL)和树的形态有关。*\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210411182309110.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUyNTc1NjA0,size_16,color_FFFFFF,t_70)\n\n二叉排序树上的查找和折半查找相差不大，最坏情况下ASL和顺序查找相同，最好情况下ASL和折半查找相似，其ASL和log2n是同数量级的，不过二叉排序树更适用于对表进行插入删除的操作。\n\n\n**二叉排序树的插入：时间复杂度O(log2n)**\n\n```c\n//二叉排序树的插入\nvoid InsertBST(BSTree &T,int e)//这里需用到C++的引用类型\n{\n    BSTree S;\n    if(!T)\n    {\n        S=malloc(sizeof(BSTNode));\n        S->data.key=e;\n        S->L=S->R=NULL;\n        T=S;\n    }\n    else if(e<T->data.key)\n    {\n        InsertBST(T->L,e);\n    }\n    else\n    {\n        InsertBST(T->R,e);\n    }\n}\n\n```\n二叉排序树的插入操作是以查找为基础的，所以时间复杂度相同，当树中不存在关键字等于key的结点时才可以插入。且因为二叉排序树的特性，插入操作只能在叶子端进行。\n\n\n**二叉排序树的创建：时间复杂度O(nlog2n)**\n\n```c\n//二叉排序树的创建\nvoid CreateBST(BSTree &T,int ENDFLAG)\n{\n    int e;\n    T=NULL;\n    scanf(\"%d\",&e);\n    while(e!=ENDFLAG)//ENDFLAG为自定义常量，作输入结束标志\n    {\n        InsertBST(T,e);\n        scanf(\"%d\",&e);\n    }\n    return ;\n}\n```\n\n二叉排序树的创建基本上就是插入n个结点，也就是调用n次插入函数，所以时间复杂度为插入函数的n倍。\n\n\n**二叉排序树的删除：时间复杂度O(log2n)**\n\n(1)若该结点为叶子结点，则直接修改双亲结点的指针\n(2)若该结点缺右子树，则用左孩子填补被删除的指针\n(3)若该结点缺左子树，则用右孩子填补被删除的指针\n(4)若该结点具有左右子树，在左子树上找中序最后一个结点（即左子树中最大的结点）填补，或在右子树上找中序第一个结点填补（即右子树最小结点）后者可能会增加树的深度，所以一般采用前者。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210411210026828.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUyNTc1NjA0,size_16,color_FFFFFF,t_70)\n\n```c\nvoid DeleteBST(BSTree &T,int key)\n{\n    BSTree p,q,s,f;\n    p=T;\n    f=NULL;\n    while(p)\n    {\n        if(p->data.key==key)\n        {\n            break;\n        }\n        f=p;\n        if(p->data.key>key)\n        {\n            p=p->L;\n        }\n        else\n        {\n            p=p->R;\n        }\n    }\n    if(!p)\n    {\n        return ;\n    }\n    q=p;\n    if(p->L&&p->R)\n    {\n        s=p->L;\n        while(s->R)\n        {\n            q=s;\n            s=s->R;\n        }\n        p->data=s->data;\n        if(q!=p)\n        {\n            q->R=s->L;\n        }\n        else\n        {\n            q->L=s->L;\n        }\n        free(s);\n        return ;\n    }\n    else if(!p->R)\n    {\n        p=p->L;\n    }\n    else if(!p->L)\n    {\n        p=p->R;\n    }\n    if(!f)\n    {\n        T=p;\n    }\n    else if(q==f->L)\n    {\n        f->L=p;   \n    }\n    else\n    {\n        f->R=p;\n    }\n    free(p);\n    return ;\n}\n```\n*同插入一样，删除的基本过程也是查找，所以时间复杂度仍是O(log2n)*\n\n\n## 平衡二叉树\n\n平衡二叉树又称**AVL树**，结点的**平衡因子**为左右子树的深度之差，可以是空树，或者是具有以下特征的二叉排序树：\n(1)左子树和右子树的深度之差的绝对值不超过1\n(2)左子树和右子树也是平衡二叉树\n\n**平衡二叉树的调整**：先按照二叉排序树进行插入，若插入结点后破坏了其平衡特性，则对平衡二叉树进行调整，主要分为四个情况\n\n（1）LL型：顺时针右旋\n（2）RR型：逆时针左旋\n（3）LR型：先逆时针左旋，再顺时针右旋\n（4）RL型：先顺时针右旋，再逆时针左旋\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210412213656928.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUyNTc1NjA0,size_16,color_FFFFFF,t_70)\n**平衡二叉树的建立**\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\ntypedef struct AVLTree\n{\n    int K;\n    int H;\n    struct AVLTree *L, *R;\n} * AVLTree, BTNode;\nint max(int a, int b)\n{\n    return a > b ? a : b;\n}\nint Depth(AVLTree T)\n{\n    if (T == NULL)\n    {\n        return -1;\n    }\n    else\n    {\n        return T->H;\n    }\n}\nAVLTree LL(AVLTree root)\n{\n    AVLTree p;\n    p = root->L;\n    root->L = p->R;\n    p->R = root;\n    root->H = max(Depth(root->L), Depth(root->R)) + 1;\n    return p;\n}\nAVLTree RR(AVLTree root)\n{\n    AVLTree p;\n    p = root->R;\n    root->R = p->L;\n    p->L = root;\n    root->H = max(Depth(root->L), Depth(root->R)) + 1;\n    return p;\n}\nAVLTree RL(AVLTree root)\n{\n    root->R = LL(root->R);\n    root = RR(root);\n    return root;\n}\nAVLTree LR(AVLTree root)\n{\n    root->L = RR(root->L);\n    root = LL(root);\n    return root;\n}\nAVLTree Insert(AVLTree root, int num)\n{\n    if (!root)\n    {\n        root = (AVLTree)malloc(sizeof(BTNode));\n        root->K = num;\n        root->H = 0;\n        root->L = NULL;\n        root->R = NULL;\n    }\n    else\n    {\n        if (num < root->K)\n        {\n            root->L = Insert(root->L, num);\n            if (abs(Depth(root->L) - Depth(root->R)) >= 2)\n            {\n                if (num > root->L->K)\n                {\n                    root = LR(root);\n                }\n                else\n                {\n                    root = LL(root);\n                }\n            }\n        }\n        else if (num == root->K)\n        {\n            //无操作\n        }\n        else\n        {\n            root->R = Insert(root->R, num);\n            if (abs(Depth(root->L) - Depth(root->R)) >= 2)\n            {\n                if (num > root->R->K)\n                {\n                    root = RR(root);\n                }\n                else\n                {\n                    root = RL(root);\n                }\n            }\n        }\n    }\n    if (Depth(root->L) == Depth(root->R))\n    {\n        root->H = 0;\n    }\n    else\n    {\n        root->H = max(Depth(root->L), Depth(root->R)) + 1;\n    }\n    return root;\n}\nvoid InOrder(AVLTree T)\n{\n    if (T == NULL)\n    {\n        return ;\n    }\n    InOrder(T->L);\n    printf(\"%d \", T->K);\n    InOrder(T->R);\n    return;\n}\nint main()\n{\n    AVLTree root = NULL;\n    int n, num;\n    printf(\"Please input the number of the BiTree node:\");\n    scanf(\"%d\", &n);\n    while (n--)\n    {\n        printf(\"Please input the Node:\");\n        scanf(\"%d\", &num);\n        root = Insert(root, num);\n    }\n    printf(\"The root node of the AVLTree is:\");\n    printf(\"%d\\n\", root->K);\n    printf(\"The InOrder of the AVLTree is:\");\n    InOrder(root);\n    return 0;\n}\n```\n*平衡二叉树的建立是以二叉排序树的插入为基础的，当树中不存在有相同值的结点时，即插入结点，之后树的深度加一，再判断是否平衡，若不平衡则进行相应的旋转操作，一步一步绘制出AVL树。*\n\n\n## B树\n\n*前面的查找方法均适用于存储在计算机内存中较小的文件，统称为内查找法。若文件很大且存放于外存进行查找时，就应该使用适用于外查找的平衡多叉树——B树*\n\n**B树（m阶)的性质：**\n（1）每个结点最多有m颗子树\n（2）若根结点不是叶子结点，则至少有两颗子树\n（3）除根之外的所有非终端结点至少有m/2颗子树\n（4）所有叶子结点都在同一层次上且不带信息，通常称为失败节点（失败结点并不存在，引入是为了更好的分析B树的查找性能）\n（5）所有的非终端结点最多有m-1个关键字\n\n\n**B树的存储**\n\n```c\n//B树的存储\ntypedef struct BTNode\n{\n    int keynum;\n    struct BTNode *parent;\n    int K[m + 1];\n    struct BTNode *ptr[m + 1];\n} BTNode, *BTree;\ntypedef struct Result\n{\n    BTNode *pt;\n    int i;\n    int tag;\n} Result;\n```\n**B树的查找**\n\n```c\n//B树的查找\nint Search(BTree T, int key)\n{\n    BTree p = T;\n    int end;\n    if (p)\n    {\n        end = p->keynum;\n    }\n    else\n    {\n        return 0;\n    }\n    int i = 0;\n    if (end == 0)\n    {\n        return i;\n    }\n    else if (key >= p->K[end])\n    {\n        i = end;\n        return i;\n    }\n    else if (key <= p->K[1])\n    {\n        return i;\n    }\n    else\n    {\n        for (i = 1; i < end; i++)\n        {\n            if (p->K[i] <= key && key < p->K[i + 1])\n            {\n                return i;\n            }\n        }\n    }\n}\nResult SearchBTree(BTree &T, int key)\n{\n    BTree p = T;\n    BTree q = NULL;\n    int found = FALSE;\n    int i = 0;\n    while (p && !found)\n    {\n        i = Search(p, key);\n        if (i > 0 && p->K[i] == key)\n        {\n            found = TRUE;\n        }\n        else\n        {\n            q = p;\n            p = p->ptr[i];\n        }\n    }\n    Result result;\n    if (found)\n    {\n        result.pt = p;\n        result.i = i;\n        result.tag = 1;\n        return result;\n    }\n    else\n    {\n        result.pt = q;\n        result.i = i;\n        result.tag = 0;\n        return result;\n    }\n}\n```\n**B树的插入**\n\n```c\n//B树的插入\nvoid Insert(BTree &q, int i, int x, BTree &ap)\n{\n    int j;\n    for (j = m - 1; j > i; j--)\n    {\n        q->K[j + 1] = q->K[j];\n    }\n    for (j = m; j > i; j--)\n    {\n        q->ptr[j] = q->ptr[j - 1];\n    }\n    q->K[i + 1] = x;\n    q->ptr[i + 1] = ap;\n    q->keynum++;\n}\nvoid Split(BTree &q, int s, BTree ap &ap)\n{\n    int i;\n    ap = malloc(sizeof(BTNode));\n    for (i = s + 1; i <= m; i++)\n    {\n        ap->K[i - s - 1] = q->K[i];\n        ap->ptr[i - s - 1] = q->ptr[i];\n    }\n    if (ap->ptr[0])\n    {\n        for (i = 0; i <= 1; i++)\n        {\n            ap->ptr[i]->parent = ap;\n        }\n    }\n    ap->keynum = (m - s) - 1;\n    ap->parent = q->parent;\n    q->keynum = q->keynum - (m - s);\n}\nvoid NewRoot(BTree T &T, BTree q, int x, BTree &ap)\n{\n    BTree NT = malloc(sizeof(BTNode));\n    NT->K[1] = x;\n    NT->ptr[0] = T;\n    NT->ptr[1] = ap;\n    NT->keynum = 1;\n    NT->parent = NULL;\n    ap->parent = NT;\n    T->parent = NT;\n    T = NT;\n}\nint InsertBTree(BTree &T, int K, BTree q, int i)\n{\n    int x = K;\n    BTree ap = NULL;\n    int finished = FALSE;\n    while (q && !finished)\n    {\n        Insert(q, i, x, ap);\n        if (q->keynum < m)\n        {\n            finished = TRUE;\n        }\n        else\n        {\n            int s = m / 2;\n            Split(q, s, ap);\n            x = ap->K[0];\n            q = q->parent;\n            if (q)\n            {\n                i = Search(q, x);\n            }\n        }\n    }\n    if (!finished)\n    {\n        NewRoot(T, q, x, ap);\n    }\n    return OK;\n}\n```\n\n## B+树\n*B+树是一种B-树的变形树，更适合文件索引系统。*\n\nB+树与B-树的差异在于：\n（1）有n颗子树的结点中含有n个关键字\n（2）所有叶子结点中包含了全部关键字的信息以及指向这些关键字的指针，且叶子结点本身依关键字的大小自小而大顺序来链接\n（3）所有非终端结点可以看成是索引部分，结点中仅含其子树（根结点）中的最大或最小关键字\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210415212614694.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUyNTc1NjA0,size_16,color_FFFFFF,t_70)\n\n\nB+树的优点程序员小灰在《漫画算法》里总结的很到位\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210415212536740.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUyNTc1NjA0,size_16,color_FFFFFF,t_70)\n\n\n通常在B+树上有两个头指针，一个指向根结点，一个指向关键字最小的叶子结点。因此我们可以对B+树进行两种查找运算\n(1)从根结点开始进行随机查找\n(2)从最小关键字起顺序查找\n\n');
INSERT INTO `article` VALUES (67, 3, '散列表查找', '散列表（哈希表）', 'C', 1638628921949, '## 哈希表\n**散列表**一般指**哈希表**，**散列查找法**又称**杂凑法**或**散列法**。\n\n*散列法通过对元素的关键字值进行某种运算，直接求出元素的地址，即使用关键字到地址的直接转换方法，而不需要反复比较。*\n*哈希表的存储空间通常是一个连续数组，散列地址是数组的下标；通常，哈希函数是一个一对多的函数，所以冲突是不可避免的，只能通过选择一个最优的哈希函数来最大的减少冲突。*\n\n**哈希函数**并不唯一，一般按照实际情况构造哈希函数，主要有：\n（1）数字分析法：当事先明确知道关键字每一位上各种数字的分布情况时适用\n（2）平方取中法：当不能事先了解关键字的所有情况或难于直接从关键字中找到取值比较分散的几位时适用\n（3）折叠法：当散列地址的位数较少而关键字的位数较多且难于直接从关键字中找到取值较分散的几位时适用\n（4）除留余数法：最常用的构造哈希函数的方法，适用范围广\n\n**冲突处理**\n\n**一、开放地址法**\n（1）线性探测法：将哈希表视作一个循环表，当发生冲突时从该地址往后找空单元进行放置，若表满则进行溢出处理\n（2）平方探测法：当发生冲突时进行第k（k从1开始）次平方运算，加上当前地址i，找到空位i+k^2进行放置，若仍然冲突，则继续进行平方运算；查找时若发现该位置上与关键字不符，则进行k的平方运算加上当前地址i，直到查找到为止，若未查找到则表中不存在该关键字\n\n```c\n//平方探测法\n#include<stdio.h>\n#define MAXSIZE 100\nvoid HashTable(int a[],int key,int k)//假设哈希函数以%3作除留余数法\n{\n    if(!a[key%3+k*k])\n    {\n        a[key%3+k*k]=key;\n    }\n    else\n    {\n        HashTable(a,key,k+1);\n    }\n}\nint HashSearch(int a[],int key,int k)\n{\n    if(k*k>MAXSIZE)\n    {\n        return -1;\n    }\n    else if(key==a[key%3+k*k])\n    {\n        return key%3+k*k;\n    }\n    else\n    {\n        return HashSearch(a,key,k+1);\n    }\n}\nint main()\n{\n    int a[MAXSIZE]={0},n,m,key;\n    printf(\"Please input the number of the elem:\");\n    scanf(\"%d\",&n);\n    while(n--)\n    {\n        int k=0;\n        scanf(\"%d\",&m);\n        HashTable(a,m,k);\n    }\n    printf(\"Please input the number you want to search:\");\n    scanf(\"%d\",&key);\n    int i=HashSearch(a,key,0);\n    if(i==-1)\n    {\n        printf(\"No such elem!\\n\");\n    }\n    else\n    {\n        printf(\"The place of the key elem is:%d\\n\",i);\n    }\n    return 0;\n}\n```\n（3）伪随机探测法：产生伪随机数，加上伪随机数取余计算下一个散列地址\n\n*处理冲突中发生的第一个散列地址不同的记录争夺后一个散列地址的现象称作* **二次聚集**或**堆积**\n\n**二、链地址法**\n\n又称**拉链法:**定义结构体数组，设置指针域，将具有相同散列地址的记录放在同一个单链表中，该单链表称为**同义词链表**。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210416202630963.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUyNTc1NjA0,size_16,color_FFFFFF,t_70)\n\n**实现代码**\n```c\n//拉链法\n#include <stdio.h>\n#include <stdlib.h>\n#define MAXSIZE 10\ntypedef struct LNode\n{\n    int key;\n    struct LNode *next;\n} LNode;\ntypedef struct HashTable\n{\n    LNode *next;\n} HashTable;\nHashTable a[MAXSIZE];\nvoid Init()\n{\n    for (int i = 0; i < 10; i++)\n    {\n        a[i].next = NULL;\n    }\n}\nvoid CreateHashTable(int key)//建立哈希表\n{\n    LNode *p, *q;\n    int i = key % 3;\n    if (a[i].next)\n    {\n        p = a[i].next;\n        while (p->next)\n        {\n            p = p->next;\n        }\n        q = malloc(sizeof(LNode));\n        q->key = key;\n        p->next = q;\n        q->next = NULL;\n    }\n    else\n    {\n        q = malloc(sizeof(LNode));\n        q->key = key;\n        a[i].next = q;\n        q->next = NULL;\n    }\n}\nLNode *HashSearch(HashTable a[], int key)//返回找到的关键字地址\n{\n    LNode *p;\n    int i = key % 3;\n    if (a[i].next)\n    {\n        p = a[i].next;\n        while (p)\n        {\n            if (p->key == key)\n            {\n                break;\n            }\n            else\n            {\n                p = p->next;\n            }\n        }\n        return p;\n    }\n    else\n    {\n        return NULL;\n    }\n}\nint main()\n{\n    LNode *k;\n    int n, m, key;\n    printf(\"Please input the node number of the HashTable:\");\n    scanf(\"%d\", &n);\n    while (n--)\n    {\n        scanf(\"%d\", &m);\n        CreateHashTable(m);\n    }\n    printf(\"Please input the key number you want to research:\");\n    scanf(\"%d\", &key);\n    k = HashSearch(a, key);\n    if (k)\n    {\n        printf(\"The key number is:%d\\n\", k->key);\n    }\n    else\n    {\n        printf(\"No answer!\\n\");\n    }\n    return 0;\n}\n```\n\n**优点：**\n(1）无堆积，便于处理冲突\n(2）哈希表插入删除操作易实现\n(3）由于是动态申请内存，适合长度变化大的哈希表存储，节省空间\n\n**各方法处理散列表的ASL（平均查找长度）**\n \n*实际情况中应根据具体情况选择最优的操作方法*');
INSERT INTO `article` VALUES (68, 4, '继承与多态', 'Java的继承与多态', 'Java', 1638629012695, '\n## 类的继承\n\n\n**基本思想:** 继承是基于父类进行拓展，以此得到一个新的子类。\n\n**作用:** 通过类的继承，我们可以复用一些定义好的类，从而减少重复代码的编写，减少软件开发周期，提高软件的可维护性和可拓展性。\n\n**操作:** 继承关系用extends关键字来标明。在子类中可以连同初始化父类来完成初始化子类的操作，用super关键字来调用父类的构造方法与成员方法等，不过子类无权调用父类private修饰的方法。\n\n当在子类中重写父类方法时，不能降低方法的修饰权限，只能将修饰权限的范围从小到大进行改变。重构是一种特殊的重写方式，除方法实现内容不同外，其他皆相同。\n\n在实例化子类对象时，Java编译器会在子类的构造方法中自动调用父类的无参构造方法（有参构造方法不能被自动调用，只能使用super关键字进行显式地调用），且调用构造方法的顺序是从父类到子类。\n\n## Object类\n**定义：** Object类是所有类的父类，Java中的每个类都是由Object类继承而来，所以在定义类时可以省略extends关键字。\n\nObject类包括许多方法，由于任何类都是Object类的子类，所以任何类可以重写Object类中的方法，不过被定义为final类型的方法不能被重写（final修饰的方法不能被重写，final修饰的类不能被继承，final修饰的变量不能被改变且必须在声明时赋值）。\n\n**Object类中的equals（）方法:**\n\n*一开始学equals（）方法和“==”运算符的时候很迷糊，百度得到的讲解很清晰，感谢答主，回答如下：*![在这里插入图片描述](https://img-blog.csdnimg.cn/20210517190059104.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUyNTc1NjA0,size_16,color_FFFFFF,t_70#pic_center)\n\n*在比较非字符串变量时，常常根据需要重写equals()方法。*\n\n\n## 对象类型转换\n\n**向上转型:** 将子类的对象看作是父类的对象，即将子类对象赋值给父类类型的变量。**（FatherType obj=new ChildType();）**\n\n**向下转型:** 将较抽象的类转换为较具体的类。（向下转型时通常将父类对象赋值予子类对象，需要进行**强制转换**。）\n\n*当进行向下转型时,若父类对象不是子类对象的实例则会出现异常，所以在执行向下转型之前通常用instanceof操作符来进行判断父类对象是否为子类对象的实例。*\n\n## 方法的重载\n\n**重载关系:** 方法名相同，参数的类型、顺序、个数不同。\n\n**不定长参数方法 格式:** 返回值 方法名（参数类型···参数名称）\n\n*不定长参数方法其实质是利用数组传参。*\n\n\n## final变量\n\n        1.final修饰的方法不能被重写\n        2.final修饰的类不能被继承\n        3.final修饰的变量不能被改变且必须在声明时赋值\n        4.final定义的常量一般使用大写字母和下划线\n        5.final修饰的方法参数预示着无法在方法中更改参数引用所指的对象\n        6.private修饰的方法被隐式指定为final类型，无需再加定义\n\n\n## 多态\n\n**基本思想:** 多态就是同一个接口，使用不同的实例来实现不同的操作。\n\n**必要条件:**\n\n1、继承关系   \n2、方法重写   \n3、向上转型\n\n**抽象类:** 抽象类是对相同类型的一种概括，不能具体说明是那一个特定的事物。\n\n我们一般将父类定义为抽象类，利用**abstract** 关键字来进行定义，抽象类和抽象方法之间是充要条件。\n\n## 接口\n\n**概念:** 接口是一系列方法的声明，是一些方法特征的集合，是解决Java无法使用多继承的手段。\n \n概念有点不明所以，这里引用博主@刘扬俊的讲解[添加链接描述](https://blog.csdn.net/qq_19782019/article/details/80259836?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162142262416780261983824%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=162142262416780261983824&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-1-80259836.pc_search_result_cache&utm_term=Java%E6%8E%A5%E5%8F%A3)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20210519194840635.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUyNTc1NjA0,size_16,color_FFFFFF,t_70#pic_center)\n**interface** 关键字用来定义接口。一个类实现一个接口，可以使用**implements** 关键字。在接口中任何字段都自动是**static**和**final** 的。\n\n*Java中不允许出现多继承，但使用接口就可以实现多继承。一个类可以将所有需要继承的接口放置在implements关键字后并使用逗号隔开，从而实现多个接口。*\n\n');
INSERT INTO `article` VALUES (69, 39, '数据库', 'SQL', 'Java', 1640593278026, '\n\n*数据库是一种存储结构，它允许使用各种格式输入、处理和检索数据，不必在每次需要数据时重新输入*\n\n**数据库特点：**\n\n(1)实现数据共享\n\n(2)减少数据的冗余度\n\n(3)数据的独立性\n\n(4)数据实现集中控制\n\n(5)数据的一致性和可维护性\n\n*数据的一致性和可维护性主要包括：安全性控制、完整性控制、并发控制、故障的发现和维护*\n\n**数据库的基本结构：**\n\n**(1)物理数据层：** 它是数据库的**最内层**，是物理存储设备上实际存储的数据集合。这些数据是原始数据，是用户加工的对象，由内部模式描述的指令操作处理的字符和字组成\n\n**(2)概念数据层：** 它是数据库的**中间层**，是数据库的整体逻辑表示，指出了每个数据的逻辑定义及数据间的逻辑联系，是存储记录的集合。它所涉及的是数据库所有对象的逻辑关系，而不是它们的物理情况，是数据库管理员概念下的数据库。\n\n**(3)逻辑数据层：** 它是数据库的**最外层**，是用户所看到和使用的数据库，是一个或一些特定用户使用的数据集合，及逻辑记录的集合\n\n\n## 数据库类型\n\n数据库一般基于某种数据模型，可以分为**层次型**、**网状型**、**关系型**及**面向对象型**等。\n\n**层次型数据库：** 类似于树结构，是一组通过链接而相互联系在一起的记录，特点是记录之间的联系通过指针实现。*（由于层次模型层次顺序严格而且复杂，因此对数据进行各项操作都很困难）*\n\n**网状型数据库：** 类似于图结构，是使用网络结构表示实体类型、实体间联系的数据模型。*（网络模型容易实现多对多的关系）*\n\n**关系型数据库：** 关系型数据库是目前最流行的数据库，是基于关系模型建立的数据库，由一系列表格组成。\n\n**面向对象型数据库：**  建立在面向对象模型基础上。\n\n## SQL语言\n\nSQL（*Structure Query language：结构化查询语言*)被广泛地应用于大多数据库中，使用SQL语言可以方便的查询、操作、定义和控制数据库中的数据。\n\n**SQL语言主要组成部分：** 数据定义语言（DDL)、数据操纵语言(DML)、数据控制语言（DCL)、事务控制语言（TCL)；在应用程序中使用最多的就是**数据操纵语言**，它最常用的核心SQL语言。\n\n**数据操纵语言**主要包括：select语句（检索）、insert语句(插入）、update语句（更新）、delete语句（删除）\n\n\n## JDBC技术\n\nJDBC是一种可用于执行SQL语句的Java API（*应用程序设计接口*），是连接数据库和Java应用程序的纽带；JDBC全称为（*Java DataBase Connectivity*)，是一套面向对象的应用程序接口，指定了统一的访问各种关系型数据库的标准接口\n\n*JDBC并不能直接访问数据库，必须依赖数据库厂商提供的JDBC驱动程序*\n\n**JDBC驱动程序的类型：**\n\n（1）JDBC-ODBC桥\n\n（2）JDBC网络驱动\n\n（3）本地协议驱动\n\n（4）本地API一部分用Java编写的驱动程序\n\n**JDBC中常用的类和接口：**\n\n**（1）Connection接口：** Connection接口代表与特定的数据库的连接，在连接上下文中执行SQL语句并返回结果\n\n**（2）Statement接口：** Statement接口用于在已经建立连接的基础上向数据库发送SQL语句\n\n**（3）PreparedStatement接口：** PreparedStatement接口用来动态地执行SQL语句\n\n**（4）DriverManager类：** DriverManager类用来管理数据库中的所有驱动程序\n\n**（5）ResultSet接口：** ResultSet接口类似于一个临时表，用来暂时存放数据库查询操作所获得的结果集\n\n\n## 数据库操作\n\n*以MySQL数据库为例*\n\n**连接数据库：** 访问数据库，首先要加载数据库的驱动程序（*只需要在第一次访问数据库时加载一次*），然后每次访问数据时创建一个Connection对象，结束时再销毁。\n\n```java\nimport java.sql.*;\n\npublic class TestSQL1 {\n    Connection C;\n    public Connection GetConnection() throws ClassNotFoundException, SQLException {\n        C= DriverManager.getConnection(\"jdbc:mysql:\"+\"//127.0.0.1:3306/world\",\"root\",\"123456\");//建立数据库连接\n        System.out.println(\"数据库连接成功\");\n        return C;\n    }\n    public static void main(String[] args) throws SQLException, ClassNotFoundException {\n        TestSQL1 c=new TestSQL1();\n        c.GetConnection();\n    }\n}\n\n```\n\n**顺序查询：**\n\n```java\nimport java.sql.*;\n\npublic class TestSQL2 {\n    static Connection C;\n    static Statement Sql;\n    static ResultSet Res;\n    public Connection GetConnection() throws SQLException {\n        C= DriverManager.getConnection(\"jdbc:mysql:\"+\"//127.0.0.1:3306/world\",\"root\",\"123456\");//建立数据库连接\n        //System.out.println(\"数据库连接成功\");\n        return C;\n    }\n\n    public static void main(String[] args) throws SQLException {\n        TestSQL2 c=new TestSQL2();\n        C=c.GetConnection();\n        Sql=C.createStatement();\n        Res=Sql.executeQuery(\"select * from  country limit 10;\");\n        while(Res.next()){\n            String Name=Res.getString(\"Name\");\n            String Code=Res.getString(\"Code\");\n            String Continent=Res.getString(\"Continent\");\n            System.out.print(\"Name:\"+Name+\" \");\n            System.out.print(\"Code:\"+Code+\" \");\n            System.out.println(\"Continent:\"+Continent);\n        }\n    }\n}\n\n```\n**模糊查询：** 可使用语句，例：`select *from country where name like \'Ch%\';`\n\n```java\nimport java.sql.*;\n\npublic class TestSQL3 {\n    static Connection C;\n    static Statement Sql;\n    static ResultSet Res;\n    public Connection GetConnection() throws SQLException {\n        C=DriverManager.getConnection(\"jdbc:mysql:\"+\"//127.0.0.1:3306/world\",\"root\",\"123456\");//建立数据库连接\n        //System.out.println(\"数据库连接成功\");\n        return C;\n    }\n\n    public static void main(String[] args) throws SQLException {\n        TestSQL3 c=new TestSQL3();\n        C=c.GetConnection();\n        Sql=C.createStatement();\n        Res=Sql.executeQuery(\"select *from country where name like \'Ch%\';\");\n        while(Res.next())\n        {\n            String Name=Res.getString(\"Name\");\n            String Code=Res.getString(\"Code\");\n            String Continent=Res.getString(\"Continent\");\n            System.out.print(\"Name:\"+Name+\" \");\n            System.out.print(\"Code:\"+Code+\" \");\n            System.out.println(\"Continent:\"+Continent);\n        }\n    }\n}\n\n```\n\n**预处理语句：** 预处理就是将客户端与数据库服务原本一次的交互分成两次；首先提交数据库语句，让数据库服务先解析该语句，其次提交参数，调用语句并执行。这样对于多次查看重复执行的语句来说，提交并解析一次语句即可，然后就可以不断的调用解析过的语句并执行执行，省去了多次解析同一条语句的时间，以此提高效率。\n\n*对SQL进行预处理时可以使用通配符＂?＂来代替任何的字段值*\n\n```java\nimport java.sql.*;\n\npublic class TestSQL4 {\n    static Connection C;\n    static PreparedStatement Sql;//声明预处理对象\n    static ResultSet Res;\n    public  Connection GetConnection() throws SQLException {\n        C= DriverManager.getConnection(\"jdbc:mysql:\"+\"//127.0.0.1:3306/world\",\"root\",\"123456\");\n        //System.out.println(\"数据库连接成功\");;\n        return C;\n    }\n\n    public static void main(String[] args) throws SQLException {\n        TestSQL4 c=new TestSQL4();\n        C=c.GetConnection();\n        Sql=C.prepareStatement(\"select *from country where Name =?\");//实例化预处理对象\n        Sql.setNString(1,\"China\");//设置参数\n        Res=Sql.executeQuery();//执行预处理语句\n        while(Res.next())\n        {\n            String Name=Res.getString(\"Name\");\n            String Code=Res.getString(\"Code\");\n            String Continent=Res.getString(\"Continent\");\n            System.out.print(\"Name:\"+Name+\" \");\n            System.out.print(\"Code:\"+Code+\" \");\n            System.out.println(\"Continent:\"+Continent);\n        }\n    }\n}\n\n```\n\n**增删查改操作：** 可通过PreparedStatement类的指定参数，动态地对数据表中原有数据进行修改操作，并通过executeUpdate()方法执行更新语句操作。\n\n```java\nimport java.sql.*;\n\npublic class TestSQL5 {\n    static Connection C;\n    static PreparedStatement Sql;\n    static ResultSet Res;\n    public Connection GetConnection() throws SQLException {\n        C= DriverManager.getConnection(\"jdbc:mysql:\"+\"//127.0.0.1:3306/jsu\",\"root\",\"123456\");\n        return C;\n    }\n\n    public static void main(String[] args) throws SQLException {\n        TestSQL5 c=new TestSQL5();\n        C=c.GetConnection();\n        Sql=C.prepareStatement(\"insert into name values(?,?,?)\");//添加数据\n        Sql.setString(1,\"100\");\n        Sql.setString(2,\"Wrthus\");\n        Sql.setString(3,\"Boy\");\n        Sql.executeUpdate();\n        Sql=C.prepareStatement(\"update name set 性别=? where 编号=1\");//更新数据\n        Sql.setString(1,\"Boy\");\n        Sql.executeUpdate();\n        Sql=C.prepareStatement(\"delete from name where 编号=100\");//删除数据\n        Sql.executeUpdate();\n        Sql=C.prepareStatement(\"select * from name\");//查询数据\n        Res=Sql.executeQuery();\n        while(Res.next())\n        {\n            String Number=Res.getString(\"编号\");\n            String Name=Res.getString(\"姓名\");\n            String Sex=Res.getString(\"性别\");\n            System.out.print(\"Number:\"+Number+\" \");\n            System.out.print(\"Name:\"+Name+\" \");\n            System.out.println(\"Sex:\"+Sex);\n        }\n    }\n}\n\n```\n\n## 数据库连接池\n\n数据库连接池预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时只许从缓冲池中取出一个，使用完毕再放回去。它允许程序重复使用一个现有的数据库连接，而不是重新建立一个。当请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。\n\n**数据库连接池种类：**　JDBC数据库连接池（*DataSource接口*）、C3P0数据库连接池、DBCP数据库连接池、Proxool数据库连接池、BoneCP数据库连接池、Druid德鲁伊数据库连接池。\n\n**Druid（德鲁伊）连接池:**\n\n```java\nimport com.alibaba.druid.pool.DruidDataSource;\nimport com.alibaba.druid.pool.DruidDataSourceFactory;\nimport org.junit.Test;\n\nimport javax.sql.DataSource;\nimport java.io.FileInputStream;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.Properties;\n\n//创建德鲁伊连接池的两种方式\npublic class TestDruid {\n\n    //方式一\n    @Test\n    public void Test_Druid1() throws SQLException {\n\n        DruidDataSource druidDataSource = new DruidDataSource();\n\n        druidDataSource.setDriverClassName(\"com.mysql.jdbc.Driver\");\n        druidDataSource.setUrl(\"jdbc:mysql://localhost:3306/world?rewriteBatchedStatements=true\");\n        druidDataSource.setUsername(\"root\");\n        druidDataSource.setPassword(\"123456\");\n        druidDataSource.setInitialSize(10);\n        druidDataSource.setMinIdle(5);\n        druidDataSource.setMaxActive(50);\n        druidDataSource.setMaxWait(5000);\n\n        //获取5000次连接\n        for(int i=0;i<5000;i++)\n        {\n            Connection connection = druidDataSource.getConnection();\n            connection.close();\n        }\n        System.out.println(\"德鲁伊连接池\");\n\n    }\n\n    //方式二\n    @Test\n    public void Test_Druid2() throws Exception {\n\n        //读取配置文件\n        Properties properties = new Properties();\n        properties.load(new FileInputStream(\"src\\\\druid.properties\"));\n\n        //创建德鲁伊连接池\n        DataSource dataSource = DruidDataSourceFactory.createDataSource(properties);\n\n        //获取5000次连接\n        for(int i=0;i<5000;i++)\n        {\n            Connection connection = dataSource.getConnection();\n            connection.close();\n        }\n        System.out.println(\"德鲁伊连接池\");\n\n    }\n}\n\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/1055c2b2323d4b5ba5a93fca326c9bb4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA54G16a2C5bel56iL5biILg==,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center)\n*Druid（德鲁伊）连接池是目前最优秀的数据库连接池*');

-- ----------------------------
-- Table structure for comment
-- ----------------------------
DROP TABLE IF EXISTS `comment`;
CREATE TABLE `comment`  (
  `article_id` int UNSIGNED NOT NULL,
  `user_id` int UNSIGNED NOT NULL,
  `comment_time` bigint NOT NULL,
  `user_comment` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  INDEX `user_comment`(`user_comment`) USING BTREE,
  INDEX `OtherUser_id`(`user_id`) USING BTREE,
  INDEX `Article_id`(`article_id`) USING BTREE,
  CONSTRAINT `Article_id` FOREIGN KEY (`article_id`) REFERENCES `article` (`article_id`) ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `OtherUser_id` FOREIGN KEY (`user_id`) REFERENCES `user` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of comment
-- ----------------------------
INSERT INTO `comment` VALUES (69, 39, 1640690413428, '德鲁伊连接池是目前最优秀的连接池');
INSERT INTO `comment` VALUES (67, 39, 1640690553779, 'HashTable');
INSERT INTO `comment` VALUES (65, 39, 1640691719400, 'B+树是一种B-树的变形树，更适合文件索引系统。');
INSERT INTO `comment` VALUES (65, 39, 1640691761751, '二叉排序树的插入操作是以查找为基础的，所以时间复杂度相同，当树中不存在关键字等于key的结点时才可以插入。且因为二叉排序树的特性，插入操作只能在叶子端进行。');
INSERT INTO `comment` VALUES (65, 39, 1640691847352, '前面的查找方法均适用于存储在计算机内存中较小的文件，统称为内查找法。');
INSERT INTO `comment` VALUES (69, 2, 1640695561291, 'Sql Boy');
INSERT INTO `comment` VALUES (58, 2, 1640695601419, '黑发不知勤学早，白首方悔读书迟');
INSERT INTO `comment` VALUES (68, 2, 1640695637042, 'Java三大特性：封装，继承，多态');
INSERT INTO `comment` VALUES (62, 2, 1640695694300, 'ShortestPath');
INSERT INTO `comment` VALUES (58, 39, 1640698388058, '不知所措，不明所以');
INSERT INTO `comment` VALUES (69, 3, 1640698534929, 'Silly Boy');
INSERT INTO `comment` VALUES (67, 3, 1640698553067, '哈希表即散列表');
INSERT INTO `comment` VALUES (60, 39, 1640698669014, 'Binary Trees.');
INSERT INTO `comment` VALUES (64, 39, 1640699588066, '二分法，效率较高，但要求线性表必须采用顺序存储结构且有序排列,而且不适用于数据元素经常变动的线性表。');
INSERT INTO `comment` VALUES (69, 4, 1640699667789, '使用Statement有sql注入风险');
INSERT INTO `comment` VALUES (64, 4, 1640699698141, '顺序查找即暴力穷举法');
INSERT INTO `comment` VALUES (61, 4, 1640699740895, '邻接矩阵本质上为二维数组');
INSERT INTO `comment` VALUES (65, 4, 1640699769368, '红黑树书上不讲');
INSERT INTO `comment` VALUES (63, 4, 1640699786464, '拓扑');
INSERT INTO `comment` VALUES (64, 39, 1641960069586, '折半查找');

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user`  (
  `id` int UNSIGNED NOT NULL AUTO_INCREMENT,
  `username` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `password` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `email` varchar(16) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NOT NULL,
  `is_admin` tinyint(1) UNSIGNED ZEROFILL NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 41 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES (1, 'Admin', '123456', 'Admin@qq.com', 1);
INSERT INTO `user` VALUES (2, 'Harry', '123456', 'Harry@qq.com', 0);
INSERT INTO `user` VALUES (3, 'Ron', '123456', 'Ron@qq.com', 0);
INSERT INTO `user` VALUES (4, 'Hermione', '123456', 'Hermione@qq.com', 0);
INSERT INTO `user` VALUES (39, 'Luna', '123456', 'Luna@qq.com', 0);

SET FOREIGN_KEY_CHECKS = 1;
